<!DOCTYPE html>
<html>
  <head>
    <title>Wacom STU-SDK Tablet Test Harness</title>
    <style type="text/css">
      body { font-family:sans-serif }
      .thirdPartyLicenses { font-size:8pt }

      table { border-collapse:collapse }
    </style>
    <script type="text/javascript" src="BigInt.js"></script>
    <script type="text/javascript" src="sjcl.js"></script>
    <script type="text/javascript" defer="defer">
    <!--
      var canvasContext;
      var canvasScaleTabletX, canvasScaleTabletY;
      var canvasScaleScreenX, canvasScaleScreenY;

      var inkingState;

      var InkState_isOff   = 0x01;
      var InkState_isOn    = 0x02;
      var InkState_isInk   = 0x04;
      var InkState_isFirst = 0x08;
      var InkState_isLast  = 0x10;

      var InkState_Up     = InkState_isOff                                              ;
      var InkState_Inking =                InkState_isOn|InkState_isInk                 ;
      var InkState_First  =                InkState_isOn|InkState_isInk|InkState_isFirst;
      var InkState_Last   = InkState_isOff|              InkState_isInk|InkState_isLast ;

      var wgssSTU = null;   // netscape plugin.
      var useActiveX;

      try {
        var test = new ActiveXObject("WacomGSS.STU.UsbDevices");
        // If the above hasn't thrown, browser is IE and components are installed
        useActiveX = true;
      }
      catch (ex) {
        // Browser isn't IE or components are not installed, either way we can't use ActiveX
        useActiveX = false;
      }

      // Create an object maintaining the compatibility beetween browsers.
      function createObject(objectName) {
        var object = null;
        try {
          if (useActiveX) {
            object = new ActiveXObject(objectName);
          } else {
            if (!wgssSTU) {
              wgssSTU = document.getElementById("wgssSTU");
            }
            object = wgssSTU.createObject(objectName);
          }
        }
        catch (e) {
          print("Exception in createObject(" + objectName + "):");
          print(e.toString());
        }
        return object;
      }


      function canvasInit(capability)
      {
        var canvas = document.getElementById("display");

        var ow = document.getElementById("mm100").offsetWidth  /  10;
        var oh = document.getElementById("mm100").offsetHeight /  10;
        var ln = document.getElementById("mm100").offsetWidth  / 100;

        inkingState = createObject("WacomGSS.STU.InkingState");
        //inkingState.setInkThreshold(inkThreshold);

        canvas.width  = capability.tabletMaxX / ow;
        canvas.height = capability.tabletMaxY / oh;

        canvasContext = canvas.getContext("2d");
        
        canvasClear();

        canvasScaleTabletX = canvas.width  / capability.tabletMaxX;
        canvasScaleTabletY = canvas.height / capability.tabletMaxY;
        canvasContext.lineWidth = 1;

        canvasScaleScreenX = canvas.width  / capability.screenWidth;
        canvasScaleScreenY = canvas.height / capability.screenHeight;
      }

      function canvasClear()
      {
        var canvas = document.getElementById("display");

        canvasContext.fillStyle = "#a0a0ff";
        canvasContext.fillRect(0,0,canvas.width,canvas.height);
      }

      function canvasClearArea(ulX, ulY, lrX, lrY)
      {
        var canvas = document.getElementById("display");

        var x = ulX;
        var y = ulY;
        var w = lrX-ulX;
        var h = lrY-ulY;

        canvasContext.fillStyle = "#a0a0ff";
        canvasContext.fillRect(canvasScaleScreenX * x, canvasScaleScreenY * y,
                               canvasScaleScreenX * w, canvasScaleScreenY * h);
      }

      var prev_penData = {}; prev_penData.sw = false;

      function canvasLineBegin(penData)
      {
      }
      function canvasLineContinue(penData)
      {
        canvasContext.beginPath();
        canvasContext.moveTo(canvasScaleTabletX * prev_penData.x, canvasScaleTabletY * prev_penData.y);
        canvasContext.lineTo(canvasScaleTabletX *      penData.x, canvasScaleTabletY *      penData.y);
        canvasContext.stroke();
      }
      function canvasLineEnd(penData)
      {
        canvasContext.beginPath();
        canvasContext.moveTo(canvasScaleTabletX * prev_penData.x, canvasScaleTabletY * prev_penData.y);
        canvasContext.lineTo(canvasScaleTabletX *      penData.x, canvasScaleTabletY *      penData.y);
        canvasContext.stroke();
      }

      function canvasOnPenData(penData)
      {
        switch (inkingState.nextState(penData.pressure))
        {
          case InkState_First:
            canvasLineBegin(penData);
            break;

          case InkState_Inking:
            canvasLineContinue(penData);
            break;

          case InkState_Last:
            if (!penData.rdy)
              penData = prev_penData;
            canvasLineEnd(penData);
            break;
        }
        prev_penData = penData;
      }
    -->
    </script>
    <script type="text/javascript" defer="defer">
    <!--

      function print(text)
      {
        var o = document.getElementById("output");
        o.value += text + "\n";
        o.scrollTop = o.scrollHeight;
      }

      function printResult(e)
      {
        var callerName = arguments.callee.caller.toString().match(/function ([^\(]+)/);
        print((callerName != null ? callerName[1] : "[noname]") + ": " + (e != null ? e.toString() : "completed"));
      }


      function toHex(value, padding)
      {
        var hex = value.toString(16);
        return "0000000000000000".substr(0,padding-hex.length)+hex;
      }

      function toHex2(value) { return toHex(value,2); }
      function toHex4(value) { return toHex(value,4); }
      function toHex8(value) { return toHex(value,8); }
      
      function fromHex(value)
      {
        return parseInt(value, 16);
      }
      
      function arrayToHex(v)
      {
        var s="";
        for (var i = 0; i < v.length; ++i)
          s = s + toHex2(v[i]);
        return s;
      }

      function hexToArray(s)
      {
        var a = new Array();
        for (var i = 0; i < s.length;i+=2)
          a.push(parseInt("0x"+ s.substr(i,2),16));
        return a;
      }

      function padLeft(str, len, pad)
      {
        if (typeof(pad) == "undefined") pad = ' ';
        str = str.toString();
        if (len > str.length)
          str = Array(len+1-str.length).join(pad) + str;
        return str;
      }

      function padRight(str, len, pad)
      {
        if (typeof(pad) == "undefined") pad = ' ';
        str = str.toString();
        if (len > str.length)
          str = str + Array(len+1-str.length).join(pad);
        return str;
      }

      function clearAllInputText()
      {
        var arr = document.getElementsByTagName("input");
        for (var i = 0; i < arr.length; ++i)
        {
          var o = arr[i];
          if (o.type != "button")
          {
            o.value = "";
          }
        }
      }

    -->
    </script>
    <script type="text/javascript" defer="defer">
    <!--
      var js;
      var ProtocolHelper;
      var usbDevices_arr;
      var tablet;

      function encryptionHandler()
      {
        var encryptionHandler = new Object();

        encryptionHandler.bigint_p    = null;
        encryptionHandler.bigint_g    = null;
        encryptionHandler.sjcl_keyAES = null;

        encryptionHandler.reset = function() 
        {
          this.bigint_p    = null;
          this.bigint_g    = null;
          this.sjcl_keyAES = null;
        }

        encryptionHandler.clearKeys = function()
        {
          this.sjcl_keyAES = null;
        }

        encryptionHandler.requireDH = function() 
        {
          return this.bigint_p == null || this.bigint_g == null; 
        }

        encryptionHandler.setDH = function(dhPrime, dhBase) 
        { 
          var p = js.toArray(dhPrime);
          var g = js.toArray(dhBase);

          this.bigint_p = str2bigInt(arrayToHex(p), 16, 128);
          this.bigint_g = str2bigInt(arrayToHex(g), 16, 0);
        }

        encryptionHandler.generateHostPublicKey = function() 
        {
          // secret key
          this.bigint_a = str2bigInt("F965BC2C949B91938787D5973C94856C", 16, 128);

          // public key
          var bigint_A = powMod(this.bigint_g, this.bigint_a, this.bigint_p);

          var hex_A = padLeft(bigInt2str(bigint_A,16), 32, '0');
          var A = hexToArray(hex_A);
          return js.toVBArray(A);
        }

        encryptionHandler.computeSharedKey = function(devicePublicKey)
        {
          var B = js.toArray(devicePublicKey);
        
          var bigint_B = str2bigInt(arrayToHex(B), 16, 128);

          var bigint_shared = powMod(bigint_B, this.bigint_a, this.bigint_p);

          var str_shared = padLeft(bigInt2str(bigint_shared,16), 32, '0');

          this.sjcl_keyAES = new sjcl.cipher.aes( sjcl.codec.hex.toBits(str_shared) );
        }

        encryptionHandler.decrypt = function(data)
        {
          var arr_cipherText  = js.toArray(data);
          var hex_cipherText  = arrayToHex(arr_cipherText);
          var sjcl_cipherText = sjcl.codec.hex.toBits(hex_cipherText);

          var sjcl_plainText = this.sjcl_keyAES.decrypt(sjcl_cipherText);

          var hex_plainText = sjcl.codec.hex.fromBits(sjcl_plainText);
          var arr_plainText = hexToArray(hex_plainText);

          return js.toVBArray(arr_plainText);
        }

        return encryptionHandler;
      }



      function encryptionHandler2()
      {
        var encryptionHandler2 = new Object();

        encryptionHandler2.bigint_e    = str2bigInt("65537",10,0);
        encryptionHandler2.bigint_d    = null;
        encryptionHandler2.bigint_N    = null;
        encryptionHandler2.sjcl_keyAES = null;

        encryptionHandler2.reset = function() 
        {
          print("encryptionHandler2.reset() called")
          this.bigint_d    = null;
          this.bigint_N    = null;
          this.sjcl_keyAES = null;
        }

        encryptionHandler2.clearKeys = function() 
        {
          print("encryptionHandler2.clearKeys() called")
          this.sjcl_keyAES = null;
        }

        encryptionHandler2.getSymmetricKeyType = function() 
        {
          print("encryptionHandler2.getSymmetricKeyType() called");
          return 2; // SymmetricKeyType_AES256
        }

        encryptionHandler2.getAsymmetricPaddingType = function() 
        {
          print("encryptionHandler2.getAsymmetricPaddingType() called")
          return 0; // AsymmetricPaddingType_None (not recommended for production!)

          //return 2; // AsymmetricPaddingType_OAEP
        }

        encryptionHandler2.getAsymmetricKeyType = function() 
        {
          print("encryptionHandler2.getAsymmetricKeyType() called")
          return 2; // AsymmetricKeyType_RSA2048
        }

        encryptionHandler2.getPublicExponent = function() 
        {
          print("encryptionHandler2.getPublicExponent() called.")
          var hex_e = padLeft(bigInt2str(this.bigint_e,16), 8, '0');
          var E = hexToArray(hex_e);
          return js.toVBArray(E);
        }


        encryptionHandler2.generatePublicKey = function() 
        { 
          print("encryptionHandler2.generatePublicKey() called")
          if (this.bigint_N != null)
          {
            print("using existing public key");
            var hex_N = padLeft(bigInt2str(this.bigint_N,16), 2048/8/2, '0');
            var N = hexToArray(hex_N);
            return js.toVBArray(N);
          }

          var calculatePrimes = document.getElementById("generatePrimes").checked;

          if (calculatePrimes)
          {
            var b = 1024;

            print("generating p...");
            var bigint_p;
            while (1)
            {
              bigint_p = randProbPrime(b);
              //bigint_p = randTruePrime(b);

              if (!equalsInt(mod(bigint_p,this.bigint_e),1))  //the prime must not be congruent to 1 modulo e
                break;
              print("retry p...");
            }

            while(1)
            {
              print("generating q...");
              var bigint_q;
              while (1)
              {
                bigint_q = randProbPrime(b);
                //bigint_q = randTruePrime(b);

                if (bigint_p != bigint_q)
                {
                  print("checking congruency...");
                  if (!equalsInt(mod(bigint_q,this.bigint_e),1))  //the prime must not be congruent to 1 modulo e
                    break;
                }
                print("retry q...");
              }

              print("generating N...");
              this.bigint_N = mult(bigint_p,bigint_q);

              print("calculating N'...");

              var bigint_phi = mult( addInt(bigint_p,-1), addInt(bigint_q,-1) )

              print("calculating d...");
              this.bigint_d = inverseMod(this.bigint_e,bigint_phi);

              if (this.bigint_d) 
              {
                break;
              }

              print("'d' not suitable");
            }
          }
          else
          {
            this.bigint_d = str2bigInt("2B1DD41FDCE1180A098EAFEFD63B8990B3964044BC2F63CB6067FBEFD6E4C76C9399E45E63B01171E9EE920A40753EB37CCBAEDE04BE726C5308FAC39E84D376D618BBC5EF1206A8CA537646DF788BC07163CB851A205DC57B61EE78F52258EDEF65F7371ABF2B10E8BF7930B655184D5EC51B972A3A0D3F5D2009EB0A6B5DFCD8DDD29CA704CDFF2086A211CFE7E0C395E9B53D5B1FF370BFC90C3A8255A64A8674E8FB41002838ABFC430EA558DECFFE1B563D96D06DCAEA8A5793DCA68C3FB4265BCE38CBEFBBAEB3B8FC1689F7B8510BF20B9D72E490887FB36F4722FEB813E6252DDC3BB17DA645ACEE8292AB85FA1A3048B7BBB34F3B50489BE7913421",16);
            this.bigint_N = str2bigInt("93DDCD8BC9E478491C54413F0484FE79DDDA464A0F53AC043C6194FD473FB75B893C783F56701D2D30B021C4EE0401F058B98F035804CFBB0E67A8136A2F052A98037457460FAB7B3B148EC7C95604FF2192EA03FCC04285EC539DDF3375678E4C4D926163ABBC609C41EF5673C449DF5AC74FFA8150D33FC5436C5CC2621E642C42C10E71BF3895B07A52E7D86C84D3A9269462CF2E484E17D34DEDFF9090D6745A00EF40EE33C71C5688E856AF3C6C42AF3C4C8523711498F4508DC18BC5E24F38C2C7E971BA61BB24B19E3AE74D4D57023AF59BA9D979FCF48080E18D920E31A319C544DEA0E9DAF088E09B6098C07C20328DD0F62C5C99FCD2EB7C4F7CD3",16);
          }

          var hex_N = padLeft(bigInt2str(this.bigint_N,16), 2048/8/2, '0');
          var N = hexToArray(hex_N);
          return js.toVBArray(N);
        }


        encryptionHandler2.computeSessionKey = function(data) 
        { 
          print("encryptionHandler2.computeSessionKey() called");
          var arr_data = js.toArray(data);

          var bigint_c = str2bigInt(arrayToHex(arr_data), 16, 2048);

          var bigint_m = powMod(bigint_c, this.bigint_d, this.bigint_N);

          var hex_k = padLeft(bigInt2str(bigint_m,16), 256/8*2, '0');

          this.sjcl_keyAES = new sjcl.cipher.aes( sjcl.codec.hex.toBits(hex_k) );
        }


        encryptionHandler2.decrypt = function(data)
        {
          var arr_cipherText  = js.toArray(data);
          var hex_cipherText  = arrayToHex(arr_cipherText);
          var sjcl_cipherText = sjcl.codec.hex.toBits(hex_cipherText);

          var sjcl_plainText = this.sjcl_keyAES.decrypt(sjcl_cipherText);

          var hex_plainText = sjcl.codec.hex.fromBits(sjcl_plainText);
          var arr_plainText = hexToArray(hex_plainText);

          return js.toVBArray(arr_plainText);
        }

        return encryptionHandler2;
      }

      //=======================================================================
      // Report Handler events


      function penData_toString(penData)
      { 
        return "rdy:"       + padRight(penData.rdy,5)
              +" sw:"       +          penData.sw
              +" pressure:" + padRight(penData.pressure,3)
              +" x:"        + padRight(penData.x,5)
              +" y:"        + padRight(penData.y,4);
      }

      function penDataTimeCountSequence_toString(penDataTimeCountSequence)
      {
        return penData_toString(penDataTimeCountSequence) 
              +" timeCount:" + padRight(penDataTimeCountSequence.timeCount,5) 
              +" sequence:"  + padRight(penDataTimeCountSequence.sequence,5);
      }


      function onPenData(penData)
      { 
        var s = "[PenData] " + penData_toString(penData);

        document.getElementById("penData").value = s;

        canvasOnPenData(penData);
      }


      function onPenDataOption(penDataOption)
      { 
        var s = "[penDataOption] " + penData_toString(penDataOption) + " option:" + padRight(penDataOption.option,5);

        document.getElementById("penData").value = s;

        canvasOnPenData(penDataOption);
      }

      function onPenDataTimeCountSequence(penDataTimeCountSequence)
      { 
        var s = "[penDataTimeCountSequence] " + penDataTimeCountSequence_toString(penDataTimeCountSequence);

        document.getElementById("penData").value = s;

        canvasOnPenData(penDataTimeCountSequence);
      }


      function onPenDataEncrypted(penDataEncrypted)
      { 
        var s = "[PenDataEncrypted] sessionId:" + toHex8(penDataEncrypted.sessionId) + "\n" + penData_toString(penDataEncrypted.penData1) + "\n" + penData_toString(penDataEncrypted.penData2);

        document.getElementById("penData").value = s;

        canvasOnPenData(penDataEncrypted.penData1);
        canvasOnPenData(penDataEncrypted.penData2);
      }

      function onPenDataTimeCountSequenceEncrypted(penDataTimeCountSequenceEncrypted)
      { 
        var s = "[penDataTimeCountSequenceEncrypted] sessionId:" + toHex8(penDataTimeCountSequenceEncrypted.sessionId) + "\n" + penDataTimeCountSequence_toString(penDataTimeCountSequenceEncrypted);

        document.getElementById("penData").value = s;

        canvasOnPenData(penDataTimeCountSequenceEncrypted);
      }



      function onPenDataEncryptedOption(penDataEncryptedOption)
      { 
        var s = "[PenDataEncryptedOption] sessionId:" + toHex8(penDataEncryptedOption.sessionId)
                + "\n" + penData_toString(penDataEncryptedOption.penData1) + " option:" + padRight(penDataEncryptedOption.option1, 5)
                + "\n" + penData_toString(penDataEncryptedOption.penData2) + " option:" + padRight(penDataEncryptedOption.option2, 5);

        document.getElementById("penData").value = s;

        canvasOnPenData(penDataEncryptedOption.penData1);
        canvasOnPenData(penDataEncryptedOption.penData2);
      }


      function onUnhandledReportData(vb_data)
      {
        try
        {
          // The report handler did not recognise the data so just display it here.

          var data = js.toArray(vb_data);
          var s = "";
          for (var i = 0; i < data.length; ++i)
          {
            s = s + " " + toHex2(data[i]);
          }
          printResult(s);
        }
        catch (e)
        {
          printResult(e);
        }
      }

      function onGetReportException(data)
      {
        try
        {
          print("onGetReportException");
        }
        catch (e)
        {
          printResult(e);
        }
      }



      function usbDeviceShortString(usbDevice)
      {
        return toHex4(usbDevice.idVendor) + ":"+ toHex4(usbDevice.idProduct) + ":" + toHex4(usbDevice.bcdDevice);
      }


      function usbDeviceString(usbDevice)
      {
        return usbDeviceShortString(usbDevice) + " " + usbDevice.fileName;
      }


      function UsbDevices_enum()
      {
        try
        {
          var select_usbDevice = document.getElementById("usbDevice"); 
          
          select_usbDevice.innerHTML=""; 
          usbDevices_arr = new Array(); 
          var i = 0;

          var usbDevices = createObject("WacomGSS.STU.UsbDevices");

          for (var i = 0; i < usbDevices.Count; ++i)
          {
            var usbDevice = usbDevices.Item(i);
            print("[foreach]: " + usbDeviceString(usbDevice));

            var o = document.createElement("option"); 
            select_usbDevice.options.add(o); 
            
            o.innerHTML       = usbDeviceShortString(usbDevice); 
            o.value           = i; 
            usbDevices_arr[i] = usbDevice;
          }

          printResult();
        }
        catch (e)
        {
          printResult(e);
        }
      }


      function UsbDevices_item()
      {
        try
        {
          var select_usbDevice = document.getElementById("usbDevice"); 
          select_usbDevice.innerHTML=""; 
          usbDevices_arr = new Array();

          var usbDevices = createObject("WacomGSS.STU.UsbDevices");

          var count = usbDevices.Count;
          print("usbDevices.Count=" + count);

          for (var i = 0; i < count; ++i)
          {
            var usbDevice = usbDevices.Item(i);
            print("["+i+"]: " + usbDeviceString(usbDevice));

            var o = document.createElement("option"); 
            select_usbDevice.options.add(o); 
            
            o.innerHTML       = usbDeviceShortString(usbDevice); 
            o.value           = i; 
            usbDevices_arr[i] = usbDevice;
          }

          printResult();
        }
        catch (e)
        {
          printResult(e);
        }
      }




      function usbConnect()
      {
        try
        {
          var usbDevices_index = document.getElementById("usbDevice").value;

          if (usbDevices_index == null || usbDevices_index == "")
          {
            UsbDevices_item();
            usbDevices_index = document.getElementById("usbDevice").value;
          }

          if (usbDevices_index == null || usbDevices_index == "")
          {
            print("No devices connected");
            return;
          }
            
          var r1 = tablet.usbConnect(usbDevices_arr[usbDevices_index], true);
          var r = r1.value;
          printResult(r);

          if (r == 0)
          {
            getPenDataOptionMode();
            getInkingMode();
            getStatus();
            var capability = getCapability();
            canvasInit(capability);
            setClearScreen();

            document.getElementById("setClearScreenArea_ulX").value = 0;
            document.getElementById("setClearScreenArea_ulY").value = 0;
            document.getElementById("setClearScreenArea_lrX").value = capability.screenWidth  - 1;
            document.getElementById("setClearScreenArea_lrY").value = capability.screenHeight - 1;
          }
          else
          {
            clearAllInputText();
          }

          
        }
        catch (e)
        {
          printResult(e);
        }
      }


      function disconnect()
      {
        try
        {
          tablet.disconnect();
          printResult();
        }
        catch (e)
        {
          printResult(e);
        }
        clearAllInputText();
      }


      function setClearScreen()
      {
        try
        {
          tablet.setClearScreen();
          printResult();
        }
        catch (e)
        {
          printResult(e);
        }
        canvasClear();
      }


      function setClearScreenArea()
      {
        var ulX, ulY, lrX, lrY;
        ulX = ulY = lrX = lrY = 0;
        try
        {
          ulX = document.getElementById("setClearScreenArea_ulX").value;
          ulY = document.getElementById("setClearScreenArea_ulY").value;
          lrX = document.getElementById("setClearScreenArea_lrX").value;
          lrY = document.getElementById("setClearScreenArea_lrY").value;

          var rc = createObject("WacomGSS.STU.Rectangle");
          rc.upperLeftXPixel  = ulX;
          rc.upperLeftYPixel  = ulY;
          rc.lowerRightXPixel = lrX;
          rc.lowerRightYPixel = lrY;

          tablet.setClearScreenArea(rc);
          printResult();
          canvasClearArea(ulX, ulY, lrX, lrY);
        }
        catch (e)
        {
          printResult(e);
        }
      }



      function getPenDataOptionMode()
      {
        var o = document.getElementById("penDataOptionMode");
        try
        {
          o.value = "";

          var v = tablet.getPenDataOptionMode();
          o.value = v.toString();
          printResult();
          return v;
        }
        catch (e)
        {
          o.value = "";
          printResult(e);
        }
      }

      function setPenDataOptionMode()
      {
        var o = document.getElementById("penDataOptionMode");
        try
        {
          var v = parseInt(o.value);
          if (!isNaN(v))
          {
            tablet.setPenDataOptionMode(v);
            printResult();
            getPenDataOptionMode();
          }
          else
            o.value = "";
        }
        catch (e)
        {
          printResult(e);
        }
      }



      function getInkingMode()
      {
        var o = document.getElementById("inkingMode");
        try
        {
          var v = tablet.getInkingMode();
          o.value = v.toString();
          printResult();
          return v;
        }
        catch (e)
        {
          o.value = "";
          printResult(e);
        }
      }

      function supportsWrite()
      {
        try
        {
          var v = tablet.supportsWrite;
          print("supportsWrite = " + v);
          return v;
        }
        catch (e)
        {
          printResult(e);
        }
      }

      function setInkingMode()
      {
        var o = document.getElementById("inkingMode");
        try
        {
          var v = parseInt(o.value);
          if (!isNaN(v))
          {
            tablet.setInkingMode(v);
            printResult();
            getInkingMode();
          }
          else
            o.value = "";
        }
        catch (e)
        {
          printResult(e);
        }
      }


      function getDevicePublicKey()
      {
        var o = document.getElementById("devicePublicKey");
        try
        {
          var v = js.toArray(tablet.getDevicePublicKey());
          o.value = arrayToHex(v);
          printResult();
          return v;
        }
        catch (e)
        {
          o.value = "";
          printResult(e);
        }
      }



      function getHostPublicKey()
      {
        var o = document.getElementById("hostPublicKey");
        try
        {
          var v = js.toArray(tablet.getHostPublicKey());
          o.value = arrayToHex(v);
          printResult();
          return v;
        }
        catch (e)
        {
          o.value = "";
          printResult(e);
        }
      }


      function setHostPublicKey()
      {
        var o = document.getElementById("hostPublicKey");

        try
        {
          var v = hexToArray(o.value);
          if (v != null)
          {
            tablet.Protocol.setHostPublicKey(js.toVBArray(v));
            printResult();
            return getHostPublicKey();
          }
          else
            o.value = "";
        }
        catch (e)
        {
          printResult(e);
        }
      }



      function endCapture()
      {
        try
        {
          tablet.endCapture();
          printResult();
        }
        catch (e)
        {
          printResult(e);
        }
        getStatus();
      }



      function getStatus()
      {
        try
        {
          var r = tablet.getStatus();
          print("Status { statusCode="+r.statusCode+" lastResultCode="+r.lastResultCode+" statusWord="+r.statusWord+" }");
          return r;
        }
        catch (e)
        {
          printResult(e);
        }
      }



      function getInformation()
      {
        try
        {
          var r = tablet.getInformation();
          print("Information {"
                +" modelName='"           + r.modelName + "'"
                +" firmwareMajorVersion=" + toHex2(r.firmwareMajorVersion)
                +" firmwareMinorVersion=" + toHex2(r.firmwareMinorVersion)
                +" secureIc="             + r.secureIc
                +" secureIcVersion="      + toHex8(r.secureIcVersion) + " }"
                );
          return r;
        }
        catch (e)
        {
          printResult(e);
        }
      }


      function getCapability()
      {
        try
        {
          var r = tablet.getCapability();
          print("Capability {"
                +" tabletMaxX="  + r.tabletMaxX
                +" tabletMaxY=" + r.tabletMaxY
                +" screenWidth=" + r.screenWidth
                +" screenHeight=" + r.screenHeight
                +" maxReportRate="    + r.maxReportRate
                +" resolution="       + r.resolution
                +" zlibColorSupport=" + r.zlibColorSupport +"}"
                );
          return r;
        }
        catch (e)
        {
          printResult(e);
        }
      }


      function startCapture()
      {
        try
        {
          print("startCapture...");
          var sessionId;
          if (document.getElementById("sessionId").value.length == 0)
          {
            sessionId = Math.floor(Math.random()*0xffffffff);
            document.getElementById("sessionId").value = toHex8(sessionId);
          }
          else 
          {
            sessionId = fromHex(document.getElementById("sessionId").value);
          }
          tablet.startCapture(sessionId); //Protocol.setS

          printResult();
        }
        catch (e)
        {
          printResult(e);
        }
      }


      function setStartCapture()
      {
        try
        {
          print("setStartCapture...");

          var p = js.toArray(tablet.getDHprime());
          var g = js.toArray(tablet.getDHbase());

          var bigint_p = str2bigInt(arrayToHex(p), 16, 128);
          var bigint_g = str2bigInt(arrayToHex(g), 16, 0);

          // secret key
          var bigint_a = str2bigInt("F965BC2C949B91938787D5973C94856C", 16, 128);

          // public key
          var bigint_A = powMod(bigint_g, bigint_a, bigint_p);

          var hex_A = padLeft(bigInt2str(bigint_A,16), 32, '0');
          document.getElementById("hostPublicKey").value = hex_A;

          var A = hexToArray(hex_A);
          var B = js.toArray(ProtocolHelper.setHostPublicKeyAndPollForDevicePublicKey(tablet, js.toVBArray(A)));
          
          //var arr_B = getDevicePublicKey();
          //if (arr_B == null) throw "getDevicePublicKey failed";

          var bigint_B = str2bigInt(arrayToHex(B), 16, 128);

          var bigint_shared = powMod(bigint_B, bigint_a, bigint_p);

          var str_shared = padLeft(bigInt2str(bigint_shared,16), 32, '0');

          print("shared ("+str_shared.length*4+" bits)="+str_shared);

          sjcl_keyAES = new sjcl.cipher.aes( sjcl.codec.hex.toBits(str_shared) );

          var sessionId;
          if (document.getElementById("sessionId").value.length == 0)
          {
            sessionId = Math.floor(Math.random()*0xffffffff);
            document.getElementById("sessionId").value = toHex8(sessionId);
          }
          else 
          {
          sessionId = fromHex(document.getElementById("sessionId").value);
          }

          tablet.startCapture(sessionId);  //Protocol.setS

          printResult();
        }
        catch (e)
        {
          printResult(e);
        }
      }


      EncodingFlag =
      {
        EncodingFlag_Zlib   : 0x01, ///< set if ZLIB is supported for color compression (not bulk).
        EncodingFlag_1bit   : 0x02,      
        EncodingFlag_16bit  : 0x04,
        EncodingFlag_24bit  : 0x08
      }
      EncodingMode =
      {
        EncodingMode_1bit       : 0x00, ///< uncompressed monochrome
        EncodingMode_1bit_Zlib  : 0x01, ///< Zlib-compressed monochrome
        EncodingMode_16bit      : 0x02, ///< uncompressed color
        EncodingMode_24bit      : 0x04, ///< uncompressed color (530 only)
        EncodingMode_1bit_Bulk  : 0x10, ///< data will be sent using Interface::write() instead of Interface::set().
        EncodingMode_16bit_Bulk : 0x12, ///< data will be sent using Interface::write() instead of Interface::set().
        EncodingMode_24bit_Bulk : 0x14 ///< data will be sent using Interface::write() instead of Interface::set() (530 only).
      }

      function writeImage()
      {
        try
        {
          var imageName = document.getElementById("imageName").value;
          if (imageName != null && imageName.length != 0)
          {
            var capability = tablet.getCapability();
            if (capability != null)
            {
              var encodingMode;
              {
                var encodingFlag = ProtocolHelper.simulateEncodingFlag(tablet.getProductId(), capability.encodingFlag);

                if (ProtocolHelper.encodingFlagSupportsColor(encodingFlag))
                {
                  if ((encodingFlag & EncodingFlag.EncodingFlag_24bit) != 0)
                  {
                    encodingMode = tablet.supportsWrite() ? EncodingMode.EncodingMode_24bit_Bulk : EncodingMode.EncodingMode_24bit;
                  }
                  else  // assume 16-bit
                  {
                    encodingMode = tablet.supportsWrite() ? EncodingMode.EncodingMode_16bit_Bulk : EncodingMode.EncodingMode_16bit;
                  }
                }
                else
                {
                  encodingMode = EncodingMode.EncodingMode_1bit;
                }
              }

              var scale = 1;
              var backgroundColor = false;
              var clip = 0;

              var imageData = ProtocolHelper.resizeAndFlatten(imageName, 0,0,0,0, capability.screenWidth, capability.screenHeight, encodingMode, scale, backgroundColor, clip);
              if (imageData != null)
              {
                tablet.writeImage(encodingMode, imageData);
              }
            }
          }
        }
        catch (e)
        {
          printResult(e);
        }
      }



      function test()
      {
        try
        {
          printResult();
        }
        catch (e)
        {
          printResult(e);
        }
      }

      function componentFiles()
      {
        try
        {
          var component = createObject("WacomGSS.STU.Component");
          var componentFiles = component.componentFiles();

          var length = componentFiles.Count;

          if (length)
          {
            print("componentFiles:");

            for (var i = 0; i < length; ++i)
            {
              var componentFile = componentFiles.Item(i);
              print('\"'+componentFile.name+"\" "+componentFile.version);
            }
          }

          printResult();
        }
        catch (e)
        {
          printResult(e);
        }
      }

      function diagnosticInformation()
      {
        try
        {
          var component = createObject("WacomGSS.STU.Component");

          var flag = 0;
          var diagnosticInformation = component.diagnosticInformation(0);

          print("diagnosticInformation("+flag+"):");

          print(diagnosticInformation);

          printResult();
        }
        catch (e)
        {
          printResult(e);
        }
      }

      function initializeGlobals()
      {
        if (js == null)
        {
          js = createObject("WacomGSS.STU.JScript"); 
        }

        if (ProtocolHelper == null)
        {
          ProtocolHelper = createObject("WacomGSS.STU.ProtocolHelper");
        }

        if (tablet == null)
        {
          tablet = createObject("WacomGSS.STU.Tablet");
          if (useActiveX)
          {
            eval("function tablet::onGetReportException(data)                 { return onGetReportException(data)                ;}");
            eval("function tablet::onUnhandledReportData(data)                { return onUnhandledReportData(data)               ;}");
            eval("function tablet::onPenData(data)                            { return onPenData(data)                           ;}");
            eval("function tablet::onPenDataOption(data)                      { return onPenDataOption(data)                     ;}");
            eval("function tablet::onPenDataEncrypted(data)                   { return onPenDataEncrypted(data)                  ;}");
            eval("function tablet::onPenDataEncryptedOption(data)             { return onPenDataEncryptedOption(data)            ;}");
            eval("function tablet::onPenDataTimeCountSequence(data)           { return onPenDataTimeCountSequence(data)          ;}");
            eval("function tablet::onPenDataTimeCountSequenceEncrypted(data)  { return onPenDataTimeCountSequenceEncrypted(data) ;}");
          } else {
            tablet.onGetReportException                 = onGetReportException;
            tablet.onUnhandledReportData                = onUnhandledReportData;
            tablet.onPenData                            = onPenData;
            tablet.onPenDataOption                      = onPenDataOption;
            tablet.onPenDataEncrypted                   = onPenDataEncrypted;
            tablet.onPenDataEncryptedOption             = onPenDataEncryptedOption;
            tablet.onPenDataTimeCountSequence           = onPenDataTimeCountSequence;
            tablet.onPenDataTimeCountSequenceEncrypted  = onPenDataTimeCountSequenceEncrypted;
          }
          tablet.encryptionHandler  = js.toTabletEncryptionHandler(encryptionHandler());
          tablet.encryptionHandler2 = js.toTabletEncryptionHandler2(encryptionHandler2());
        }
      }

      function body_onload()
      {
        if (document.readyState != "complete") 
        { 
          window.setTimeout(body_onload(),100);
          return;
        }
        print("loaded");
        initializeGlobals();
        
        var e = encryptionHandler2();
        e.test();
      }

    -->
    </script>
  </head>
  <body onload="body_onload()" >
    <div id="mm100" style="position:absolute;left:0;top:0;width:100mm;height:100mm;z-index:-1"></div>

    <div style="font-size:8pt">[version 2.1.0]</div>
    <table border="0" style="width:100%">
    <tr>
    <td style="width:50%">
    <div>
      <input type="button" onclick="UsbDevices_enum()"        value="UsbDevices [enum]"        />
      <input type="button" onclick="UsbDevices_item()"        value="UsbDevice [item]"        />
    </div>
    <div>
      <input type="button" onclick="usbConnect()"  value="usbConnect" />
      <select id="usbDevice">
      </select>
    </div>
    <div>
      <input type="button" onclick="disconnect()"            value="disconnect"            />
    </div>
    <div>
      <input type="button" onclick="supportsWrite()" value="supportsWrite" />
      <input type="button" onclick="getStatus()"             value="getStatus"             />
      <input type="button" onclick="getInformation()"        value="getInformation"        />
      <input type="button" onclick="getCapability()"        value="getCapability"        />
      <input type="button" onclick="setClearScreen()"        value="setClearScreen"        />
    </div>
    <div>
      <input type="button" onclick="getPenDataOptionMode()" value="getPenDataOptionMode" />
      <input type="button" onclick="setPenDataOptionMode()" value="setPenDataOptionMode" />
      <input type="text"   id="penDataOptionMode"   size="20"/>
    </div>
    <div>
      <input type="button" onclick="getInkingMode()" value="getInkingMode" />
      <input type="button" onclick="setInkingMode()" value="setInkingMode" />
      <input type="text"   id="inkingMode"   size="20"/>
    </div>
    <div>
      <input type="button" onclick="setClearScreenArea()" value="setClearScreenArea" />
      ( <input type="text"   id="setClearScreenArea_ulX"   size="4"/> , <input type="text"   id="setClearScreenArea_ulY"   size="4"/> )
      
      ( <input type="text"   id="setClearScreenArea_lrX"   size="4"/> , <input type="text"   id="setClearScreenArea_lrY"   size="4"/> )
    </div>
    </td>
    <td style="width:50%">
    Encryption support:
    <div>
      v1:
      <div>
        <input type="button" onclick="getHostPublicKey()" value="getHostPublicKey" />
        <input type="button" onclick="setHostPublicKey()" value="setHostPublicKey" />
        <input type="text"   id="hostPublicKey"   size="40"/>
      </div>
      <div>
        <input type="button" onclick="getDevicePublicKey()" value="getDevicePublicKey" />
        <input type="text"   id="devicePublicKey"   size="40"/>
      </div>
    </div>
    <div>
      v2:
      <div>
        <input type="checkbox" id="generatePrimes"/><span style="font-style:italic">generate primes</span>
      </div>
    </div>
    <div>
      all:
      <div>
        <input type="button"   onclick="startCapture()"       value="startCapture"       />
        <input type="button"   onclick="endCapture()"         value="endCapture"         />
        <input type="text"     id="sessionId"   size="20"/>
      </div>
    </div>
    Image Support:
    <div>
      <input type="text"     id="imageName"   size="40"/>
      <input type="button"   onclick="writeImage()" value="writeImage" />
    </div>
    </td>
    </tr>
    <tr>
    <td>
    <div>
      <input type="button" onclick="componentFiles()"                  value="componentFiles"                  />
      <input type="button" onclick="diagnosticInformation()"           value="diagnosticInformation"                  />
    </div>
    </td>
    </tr>
    <tr>
    <td>
    <div>
      <input type="button" onclick="test()"                  value="test"                  />
    </div>
    </td>
    </tr>
    </table>
            
    <div>
    <canvas id="display" width="200" height="200" style="background:#a0a0a0"></canvas>
    <br/>
    <textarea cols="132" rows="3" id="penData"></textarea>
    <br/>
    <textarea cols="132" rows="10" id="output"></textarea>
    </div>

    <div class="thirdPartyLicenses">
      <div>
        Diffie-Hellman key exchange uses the Big Integer Library by Leemon Baird. Public domain.
      </div>
      <div>
        AES decryption provided by the SJCL library, Copyright 2009-2010 Emily Stark, Mike Hamburg, Dan Boneh. All rights reserved.
        <div style="display:none;white-space:pre;font-family:monospace">Copyright 2009-2010 Emily Stark, Mike Hamburg, Dan Boneh.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

   1. Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
   2. Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

THIS SOFTWARE IS PROVIDED BY THE AUTHORS &ldquo;AS IS&rdquo; AND ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL &lt;COPYRIGHT HOLDER&gt; OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The views and conclusions contained in the software and documentation
are those of the authors and should not be interpreted as representing
official policies, either expressed or implied, of the authors.</div>
      </div>
    </div>
    <div >
      <object id="wgssSTU" type="application/x-wgssSTU" ></object>
      <!-- style="height:5px;"-->
    </div>  
  </body>
</html>
